<html>
  <head>
    <title>3D Gardener</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: #000;
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 10px;
    				width: 100%;
    				text-align: center;
    			}
    </style>

    <div id="info">
      <p>3D Gardener</p>
    </div>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
		
	<script type="module">
    import * as THREE from 'three';
    import * as WEATHER from './Weather.js';
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { GUI } from './build/dat.gui.module.js';
    import { MTLLoader } from './jsm/loaders/MTLLoader.js';
    import { OBJLoader } from './jsm/loaders/OBJLoader.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';

    let scene, camera, renderer, controls, directionalLight, rain, spotlight,
    posAttr, floorMesh, materialFloor, cube, sun, sunOn = false, rainOn = false;

    const options = 
    {
      addObject: 'Sunflower',
      deleteMode: false,
      showSpotlightHelper: true,
      floorColor: '#aecd54',
      spotlight: {
      color: '#ffffff',
      intensity: 0.5,
      position: { x: 10, y: 40, z: 40 },
      angle: Math.PI / 6,
      penumbra: 1,
      },
      sunFlowerColor: '#ffffff',
      cactusColor: '#ffffff' ,
      zinniasColor: '#ffffff',
      lilliesColor: '#ffffff',
      lungwortColor: '#ffffff'
    };

    function init() {
      scene = new THREE.Scene( );
      var ratio = window.innerWidth/window.innerHeight;
      camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000);
      sunOn = false;

      camera.position.set(0,3,30);
      camera.lookAt(0,0,1);

      renderer = new THREE.WebGLRenderer( );
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement );

      //CONTROLS
      controls = new OrbitControls( camera, renderer.domElement );
      var spotlightHelperVisible = true; 
      //CLOCK
      const clock = new THREE.Clock();

      rain = WEATHER.createRain();
      posAttr = WEATHER.getPositionAttributes();
      scene.add(rain);

      sun = WEATHER.createSun();
      scene.add(sun);
      scene.add(sun.target);

      // Lighting
      var cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.5);
      camera.add(cameralight);
      scene.add(camera);

      var ambientlight = new THREE.AmbientLight(new THREE.Color(1, 1, 1), 0.2);
      scene.add(ambientlight);

      // Spotlight
      spotlight = new THREE.SpotLight(new THREE.Color(1, 1, 1), 0.5);
      spotlight.position.set(10, 40, 40);
      spotlight.angle = Math.PI / 6;
      spotlight.penumbra = 1;
      spotlight.castShadow = true;
      spotlight.shadow.mapSize.width = 2048;
      spotlight.shadow.mapSize.height = 2048;
      scene.add(spotlight);

      // Create floor
      const createFloor = () => 
      {
        const normal_map = new THREE.TextureLoader().load('Models/Floor/wispy-grass-meadow_normal-ogl.png');
        normal_map.wrapS = normal_map.wrapT = THREE.RepeatWrapping;
        normal_map.repeat = new THREE.Vector2(1, 1);

        materialFloor = new THREE.MeshPhongMaterial({ 
          shininess: 100,
          side: THREE.DoubleSide,
          color: new THREE.Color(options.floorColor),
          normalMap: normal_map,
        });

        const geometryFloor = new THREE.PlaneGeometry(200, 200);
        floorMesh = new THREE.Mesh(geometryFloor, materialFloor);
        floorMesh.rotation.x -= Math.PI / 2;
        floorMesh.position.y -= 10;
        floorMesh.receiveShadow = true;
        floorMesh.name = "Floor";
        scene.add(floorMesh);
      };
      createFloor();

      // Spotlight Helper
      var spotLightHelper = new THREE.SpotLightHelper(spotlight);
      scene.add(spotLightHelper);

      // Function to toggle spotlight helper visibility
      const toggleSpotlightHelper = () => {
        spotLightHelper.visible = options.showSpotlightHelper;
      };
      toggleSpotlightHelper();
      
      // Shadows
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      animate();

    }
    
    function animate() {
      sun.visible = sunOn;
      // sunColourChange(sunOn);
      rain.visible = rainOn;
      posAttr = WEATHER.animateRain();
      posAttr.needsUpdate = true;

      let toRemove = []; // hold objects to remove

      scene.traverse((object) => {
        if (object.name === "Plant"){
          if (rainOn) {
                object.value += (object.userData.type === "Sunflower" || object.userData.type === "Cactus") ? -0.1 : 0.1;
            }
            if (sunOn) {
                object.value += (object.userData.type === "Sunflower" || object.userData.type === "Cactus") ? 0.2 : -0.1;
            }
          console.log(object.value);
          //normalize it so its only from 0 - 100
          object.value = Math.max(0, Math.min(100, object.value));
          
          //grows the flower
          if(object.value > 50){
            let scaleIncrement = (object.value - 50) / 50;
            let newScale = object.originalScale.clone().multiplyScalar(1 + scaleIncrement * 0.25);
            object.scale.set(newScale.x, newScale.y, newScale.z);
          } else {
            object.scale.set(object.originalScale.x, object.originalScale.y, object.originalScale.z);
          }

          object.traverse((node) => {
            if (node.isMesh) { 
              if (object.value < 20 && object.value > 0) {
                node.material.color.set(0xFF0000); // Set to brown
            } else {
              node.material.color.set(0xFFFFFF); // Set to default colour
            }
          }
        });

        if(object.value <= 0){
          toRemove.push(object);
        }

        // LILY
        if (object.userData.type === "Lily" && rainOn) {
          object.position.y += 0.01;  // Move up slightly when it rains
          // limit the movement 
          object.position.y = Math.min(object.position.y, object.originalPosition.y + 1);
        } else if (object.userData.type === "Lily" && sunOn) {
          //reset position
          object.position.y = Math.max(object.originalPosition.y, object.position.y - 0.01);
        }

        //Zinnias
        if (object.userData.type === "Zinnias" && rainOn) {
          object.position.y += 0.01;  // Move up slightly when it rains
          object.position.y = Math.min(object.position.y, object.originalPosition.y + 5);
        } else if (object.userData.type === "Zinnias" && sunOn) {
          //reset position
          object.position.y = Math.max(object.originalPosition.y, object.position.y - 0.01);
        }
      } 
    });

      // Remove objects
      toRemove.forEach((object) => {
        scene.remove(object);
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
          if (object.material.map) object.material.map.dispose(); 
            object.material.dispose(); // Dispose material
          }
      });

      renderer.render(scene,camera);
      controls.update();
      requestAnimationFrame(animate);

    }

    init();

    const gltfLoader = new GLTFLoader()
      
    //Function of cactus
    const addCactus = (position) => {
      gltfLoader.load('./Models/cactus_1/scene.gltf', (gltf) => {
        gltf.scene.position.copy(position);
        gltf.scene.name = "Plant";
        gltf.scene.userData.type = "Cactus";
        gltf.scene.value = 50; 
        gltf.scene.originalScale = new THREE.Vector3(1, 1, 1); 

        //shadows
        gltf.scene.traverse((node) => 
        {
          if (node.isMesh)
          {
            node.castShadow = true;
            node.material.color.set(options.cactusColor);
          }
        });
        
          scene.add(gltf.scene);
      });
    };

    //Creates Sunflower
    //sunflowers thrive on extreme heat
    const addSunflower = (position) => {
      gltfLoader.load('./Models/sunflower/scene.gltf', (gltf) =>{
        gltf.scene.position.copy(position);
        gltf.scene.rotation.y = THREE.MathUtils.degToRad(270);
        gltf.scene.scale.set(0.1, 0.1, 0.1);
        gltf.scene.name = "Plant";
        gltf.scene.userData.type = "Sunflower";
        gltf.scene.value = 50; 
        //original Scale for rain
        gltf.scene.originalScale = new THREE.Vector3(0.1, 0.1, 0.1); 


        //shadows
        gltf.scene.traverse((node) => 
        {
          if (node.isMesh)
          {
            node.castShadow = true;
            node.material.color.set(options.sunFlowerColor);
          }
        });

        scene.add(gltf.scene);
      })
    }

    //Creates Zinnias
    const addZinnias = (position)=> {
      gltfLoader.load('./Models/Zinnias/scene.gltf', (gltf) =>{
        gltf.scene.position.copy(position);
        gltf.scene.position.y += 22
        gltf.scene.scale.set(0.25, 0.25, 0.25);
        gltf.scene.name = "Plant";
        gltf.scene.userData.type = "Zinnias";
        gltf.scene.originalPosition = new THREE.Vector3(position.x, position.y + 22, position.z);  // Store original position
        gltf.scene.value = 50; 
        //original Scale for rain
        gltf.scene.originalScale = new THREE.Vector3(0.25, 0.25, 0.25); 

        //shadows
        gltf.scene.traverse((node) => 
        {
          if (node.isMesh)
          {
            node.castShadow = true;
            node.material.color.set(options.zinniasColor);
          }
        });

        scene.add(gltf.scene);
      });
    }

    //Create lilies
    //extreme rain
    const addLillies = (position)=> {
      gltfLoader.load('./Models/purple_lilies/scene.gltf', (gltf) =>{
        gltf.scene.position.copy(position);
        gltf.scene.position.y += 8.25
        gltf.scene.name = "Plant";
        gltf.scene.userData.type = "Lily";  
        gltf.scene.value = 50;
        gltf.scene.originalScale = new THREE.Vector3(1, 1, 1);
        //original Position
        gltf.scene.originalPosition = new THREE.Vector3(position.x, position.y + 8.25, position.z); 

        //shadows
        gltf.scene.traverse((node) => 
        {
          if (node.isMesh)
          {
            node.castShadow = true;
            node.material.color.set(options.lilliesColor);
          }
        });

        scene.add(gltf.scene);
      });
    }

     //Create Rose
     const addRose = (position)=> {
      gltfLoader.load('./Models/rose_flower/scene.gltf', (gltf) =>{
        gltf.scene.position.copy(position);
        gltf.scene.position.y += 5.3
        gltf.scene.name = "Plant";
        gltf.scene.userData.type = "Rose";
        gltf.scene.value = 50;
        gltf.scene.scale.set(2.5, 2.5, 2.5);
        gltf.scene.originalScale = new THREE.Vector3(2.5, 2.5, 2.5);

        //shadows
        gltf.scene.traverse((node) => 
        {
          if (node.isMesh)
          {
            node.castShadow = true;
            node.material.color.set(options.lilliesColor);
          }
        });

        scene.add(gltf.scene);
      });
    }

    //Create Lungwort
    //rain
    const addLungwort = (position) => {
      gltfLoader.load('./Models/Lungwort/scene.gltf', (gltf) =>{
        gltf.scene.position.copy(position);
        gltf.scene.scale.set(20,20,20);
        gltf.scene.name = "Plant";
        gltf.scene.userData.type = "Lungwort";
        gltf.scene.value = 50; 
        //original Scale for rain
        gltf.scene.originalScale = new THREE.Vector3(20, 20, 20); 

        //shadows
        gltf.scene.traverse((node) => 
        {
          if (node.isMesh)
          {
            node.castShadow = true;
            node.material.color.set(options.lungwortColor);
          }
        });

        scene.add(gltf.scene);
      });
    }

    var MyResize = function ( )
    {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width,height);
      camera.aspect = width/height;
      camera.updateProjectionMatrix();
      renderer.render(scene,camera);
    };

    window.addEventListener( 'resize', MyResize);

    const gui = new GUI();
    
    //GUI
    const weather = {
        RainVar: false,
        SunVar: false,
    };

    

    const spotlightControls = 
    {
      color: spotlight.color.getHex(),
      intensity: spotlight.intensity,
      position: spotlight.position,
      angle: spotlight.angle,
      penumbra: spotlight.penumbra
    };

    gui.add(options, 'addObject', ['Sunflower', 'Cactus', 'Zinnias', 'Lillies','Lungwort', 'Rose']).name('Add Object');
    gui.add(options, 'deleteMode').name('Delete Mode').onChange((enabled) =>{
      console.log("Delete Mode: " + (enabled ? "Enabled" : "Disabled"));
    })
    gui.add(options, 'showSpotlightHelper').name('Show Spotlight Helper').onChange(() => {
      toggleSpotlightHelper();
    });
    gui.addColor(options, 'floorColor').name('Floor Color').onChange(() => {
      const floorColor = new THREE.Color(options.floorColor);
      materialFloor.color = floorColor;
    });
    //const flowerColor = gui.addFolder('Plant Color');
    // flowerColor.addColor(options, 'sunFlowerColor').name('Sunflower Color').onChange(addSunflower);
    // flowerColor.addColor(options, 'cactusColor').name('Cactus Color').onChange(addCactus);
    // flowerColor.addColor(options, 'lilliesColor').name('Lillies Color').onChange(addLillies);
    // flowerColor.addColor(options, 'lungwortColor').name('Lungwort Color').onChange(addLungwort);
    // flowerColor.addColor(options, 'zinniasColor').name('Zinnias Color').onChange(addZinnias);
    
    const spotlightFolder = gui.addFolder('Spotlight');
    spotlightFolder.addColor(spotlightControls, 'color').name('Color').onChange(() => {
      spotlight.color.set(spotlightControls.color);
    });
    spotlightFolder.add(spotlightControls, 'intensity', 0, 1).name('Intensity').onChange(() => {
      spotlight.intensity = spotlightControls.intensity;
    });
    spotlightFolder.add(spotlightControls.position, 'x', -50, 200).name('X Position').onChange(() => {
      spotlight.position.x = spotlightControls.position.x;
    });
    spotlightFolder.add(spotlightControls.position, 'y', -50, 200).name('Y Position').onChange(() => {
      spotlight.position.y = spotlightControls.position.y;
    });
    spotlightFolder.add(spotlightControls.position, 'z', -50, 200).name('Z Position').onChange(() => {
      spotlight.position.z = spotlightControls.position.z;
    });
    spotlightFolder.add(spotlightControls, 'angle', 0, Math.PI).name('Angle').onChange(() => {
      spotlight.angle = spotlightControls.angle;
    });
    spotlightFolder.add(spotlightControls, 'penumbra', 0, 2).name('Penumbra').onChange(() => {
      spotlight.penumbra = spotlightControls.penumbra;
    });

    gui.add(weather, 'RainVar').name('Rain').onChange(value => {rainOn = value});
    gui.add(weather, 'SunVar', 0, 1).name('Sun').onChange(value => {sunOn = value});
    

    const updateSpotlight = () => 
    {
      spotlight.color.set(options.spotlight.color);
      spotlight.intensity = options.spotlight.intensity;
      spotlight.position.set(options.spotlight.position.x, options.spotlight.position.y, options.spotlight.position.z);
      spotlight.angle = options.spotlight.angle;
      spotlight.penumbra = options.spotlight.penumbra;
      spotLightHelper.update();
    };

    

    

    // Raycaster
    var raycaster = new THREE.Raycaster();
    document.addEventListener('mousedown', (event) => {
      const mousePos = new THREE.Vector2();
      mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mousePos, camera);

      const intersects = raycaster.intersectObjects(scene.children, true);

      if (intersects.length > 0) {
        if (options.deleteMode) {
          // deletion
          for (let intersect of intersects) {
            let target = intersect.object;
            while (target.parent && target.parent !== scene) {
              if (target.parent.name === "Plant") {
                target = target.parent;
                break;
              }
              target = target.parent;
            }
            if (target.name === "Plant") {
              scene.remove(target);
              // deleting resources
              target.traverse(node => {
                if (node.geometry) node.geometry.dispose();
                if (node.material) node.material.dispose();
              });
              break; 
            }
          }
        } else {
          // Handle adding plants
          const floorIntersect = intersects.find(intersect => intersect.object.name === "Floor");
          if (floorIntersect) {
            const newPosition = floorIntersect.point;
            switch(options.addObject) {
              case 'Cactus':
                addCactus(newPosition);
                break;
              case 'Sunflower':
                addSunflower(newPosition);
                break;
              case 'Zinnias':
                addZinnias(newPosition);
                break;
              case 'Lillies':
                addLillies(newPosition);
                break;
              case 'Lungwort':
                addLungwort(newPosition);
                break;
              case 'Rose':
                addRose(newPosition);
                break;
            }
          }
        }
      }
    });


    // Function to update floor color
    const updateFloorColor = () => {
      const floorColor = new THREE.Color(options.floorColor);
      if (materialFloor) { 
        materialFloor.color = floorColor;
        materialFloor.needsUpdate = true;
      }
    };
    updateFloorColor();


  </script>
  </body>
</html>
