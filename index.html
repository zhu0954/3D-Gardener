<html>
  <head>
    <title>3D Gardener</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: #00c3ff;
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 10px;
    				width: 100%;
    				text-align: center;
    			}
    </style>

    <div id="info">
      <p>3D Gardener</p>
    </div>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
		</script>
		
	<script type="module">
    import * as THREE from 'three';
    import * as WEATHER from './Weather.js';
    import * as PLANTS from './Plants.js';
    import * as UI from './UserInterface.js'
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { GUI } from './build/dat.gui.module.js';

    let scene, camera, renderer, controls, directionalLight, rain, spotlight,
    posAttr, floorMesh, materialFloor, cube, sun, sunOn = false, rainOn = false;

    const options = UI.options;

    function init() {
      scene = new THREE.Scene( );
      var ratio = window.innerWidth/window.innerHeight;
      camera = new THREE.PerspectiveCamera(45,ratio,0.1,1000);
      sunOn = false;

      camera.position.set(0,3,30);
      camera.lookAt(0,0,1);

      renderer = new THREE.WebGLRenderer( );
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement );

      //CONTROLS
      controls = new OrbitControls( camera, renderer.domElement );
      var spotlightHelperVisible = true; 
      //CLOCK
      const clock = new THREE.Clock();

      rain = WEATHER.createRain();
      posAttr = WEATHER.getPositionAttributes();
      scene.add(rain);

      sun = WEATHER.createSun();
      scene.add(sun);
      scene.add(sun.target);

      // Lighting
      var cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.5);
      camera.add(cameralight);
      scene.add(camera);

      var ambientlight = new THREE.AmbientLight(new THREE.Color(1, 1, 1), 0.2);
      scene.add(ambientlight);

      // Spotlight
      spotlight = new THREE.SpotLight(new THREE.Color(1, 1, 1), 0.5);
      spotlight.position.set(10, 40, 40);
      spotlight.angle = Math.PI / 6;
      spotlight.penumbra = 1;
      spotlight.castShadow = true;
      spotlight.shadow.mapSize.width = 2048;
      spotlight.shadow.mapSize.height = 2048;
      scene.add(spotlight);

      // Create floor
      const createFloor = () => 
      {
        const normal_map = new THREE.TextureLoader().load('Models/Floor/wispy-grass-meadow_normal-ogl.png');
        normal_map.wrapS = normal_map.wrapT = THREE.RepeatWrapping;
        normal_map.repeat = new THREE.Vector2(1, 1);

        materialFloor = new THREE.MeshPhongMaterial({ 
          shininess: 100,
          side: THREE.DoubleSide,
          color: new THREE.Color(options.floorColor),
          normalMap: normal_map,
        });

        const geometryFloor = new THREE.PlaneGeometry(200, 200);
        floorMesh = new THREE.Mesh(geometryFloor, materialFloor);
        floorMesh.rotation.x -= Math.PI / 2;
        floorMesh.position.y -= 10;
        floorMesh.receiveShadow = true;
        floorMesh.name = "Floor";
        scene.add(floorMesh);
      };
      createFloor();

      // Spotlight Helper
      var spotLightHelper = new THREE.SpotLightHelper(spotlight);
      scene.add(spotLightHelper);

      // Function to toggle spotlight helper visibility
      const toggleSpotlightHelper = () => {
        spotLightHelper.visible = options.showSpotlightHelper;
      };
      toggleSpotlightHelper();
      
      // Shadows
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      animate();

    }
    
    function animate() {
      sun.visible = sunOn;
      rain.visible = rainOn;
      posAttr = WEATHER.animateRain();
      posAttr.needsUpdate = true;
      PLANTS.weatherEffects(scene, rainOn, sunOn);
      if(rainOn){
        renderer.setClearColor(0x00008B);
      }
      else{
        renderer.setClearColor(0x87ceeb);
      }
      renderer.render(scene,camera);
      controls.update();
      requestAnimationFrame(animate);

    }

    init();
    renderer.setClearColor(0x87ceeb);

    var MyResize = function ( )
    {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width,height);
      camera.aspect = width/height;
      camera.updateProjectionMatrix();
      renderer.render(scene,camera);
    };

    window.addEventListener( 'resize', MyResize);
    
    //GUI
    const gui = UI.gui;
    const weather = UI.weather;
    const spotlightControls = UI.spotlightControlsConstant(spotlight);
    UI.createSpotlightControls(spotlight, spotlightControls);

    gui.add(weather, 'RainVar').name('Rain').onChange(value => {rainOn = value});
    gui.add(weather, 'SunVar', 0, 1).name('Sun').onChange(value => {sunOn = value});

    // Raycaster
    var raycaster = new THREE.Raycaster();
    document.addEventListener('mousedown', (event) => {
      const mousePos = new THREE.Vector2();
      mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mousePos, camera);

      const intersects = raycaster.intersectObjects(scene.children, true);

      if (intersects.length > 0) {
        if (options.deleteMode) {
          // deletion
          for (let intersect of intersects) {
            let target = intersect.object;
            while (target.parent && target.parent !== scene) {
              if (target.parent.name === "Plant") {
                target = target.parent;
                break;
              }
              target = target.parent;
            }
            if (target.name === "Plant") {
              scene.remove(target);
              // deleting resources
              target.traverse(node => {
                if (node.geometry) node.geometry.dispose();
                if (node.material) node.material.dispose();
              });
              break; 
            }
          }
        } else {
          // Handle adding plants
          const floorIntersect = intersects.find(intersect => intersect.object.name === "Floor");
          if (floorIntersect) {
            const newPosition = floorIntersect.point;
            switch(options.addObject) {
              case 'Cactus':
                PLANTS.addCactus(scene, newPosition, options.cactusColor);
                break;
              case 'Sunflower':
                PLANTS.addSunflower(scene, newPosition, options.sunFlowerColor);
                break;
              case 'Zinnias':
                PLANTS.addZinnias(scene, newPosition, options.zinniasColor);
                break;
              case 'Lillies':
                PLANTS.addLillies(scene, newPosition, options.lilliesColor);
                break;
              case 'Lungwort':
                PLANTS.addLungwort(scene, newPosition, options.lungwortColor);
                break;
              case 'Rose':
                PLANTS.addRose(scene, newPosition);
                break;
            }
          }
        }
      }
    });


    // Function to update floor color
    const updateFloorColor = () => {
      const floorColor = new THREE.Color(options.floorColor);
      if (materialFloor) { 
        materialFloor.color = floorColor;
        materialFloor.needsUpdate = true;
      }
    };
    updateFloorColor();


  </script>
  </body>
</html>
