<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Gardener</title>
  <style>
    body {
      margin: 0;
      font-family: Monospace;
      background-color: #00c3ff;
      color: #fff;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
    }

  </style>
</head>
<body>
  <div id="info">
    <p>3D Gardener</p>
  </div>
  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import * as WEATHER from './Weather.js';
    import * as PLANTS from './Plants.js';
    import * as UI from './UserInterface.js';
    import * as GRASS from './Grass.js'
    import * as ENV from './Environment.js'
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { PointerLockControls } from './jsm/controls/PointerLockControls.js';
    import { GUI } from './build/dat.gui.module.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
    import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';

    let scene, camera, renderer, controls, pointcontrols, floorMesh, materialFloor, naturalLight = [],
    base, path, dirt, building, frontEdge, backEdge, leftEdge, rightEdge, time = "day", heat, rain, posAttr,
    sunPower = 0, rainPower = 0;
    const flowerOptions = UI.flowerOptions;
    const grassOptions = UI.grassOptions;
    const clock = new THREE.Clock();  // Define clock here

    function init() {
      scene = new THREE.Scene();
      var ratio = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);

      camera.position.set(0, 200, 350);
      camera.lookAt(0, 0, 1);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // CONTROLS
      controls = new OrbitControls(camera, renderer.domElement);
      pointcontrols = new PointerLockControls( camera, document.body );

      // Natural Light
      naturalLight = ENV.naturalLight();
      for (var i = 0; i < 4; i++)
        scene.add(naturalLight[i]);

      // Rain
      rain = WEATHER.createRain();
      posAttr = WEATHER.getPositionAttributes();
      scene.add(rain);

      // Extreme Sun
      heat = WEATHER.createExtremeSun();
      scene.add(heat);
      scene.add(heat.target);

      //Lighting
      var cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.1); // Reduced intensity
      camera.add(cameralight);
      scene.add(camera);

      var ambientlight = new THREE.AmbientLight(new THREE.Color(1, 1, 1), 0.1); // Reduced intensity
      scene.add(ambientlight);

  
      // Shadows
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.gammaFactor = 2.2;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.75; 

      // Create Garden
      GRASS.gardenCreator(scene);
      base = GRASS.getBase();
      dirt = GRASS.getDirt();
      path = GRASS.getPath();

      // Adding building underneath
      ENV.addRooftopElements(scene);
      ENV.addBuilding(scene);

      building = ENV.getBuilding();
      frontEdge = ENV.getFrontEdge();
      backEdge = ENV.getBackEdge();
      rightEdge = ENV.getRightEdge();
      leftEdge = ENV.getLeftEdge();

      animate();
    }
    var lock = false;
    var fogCount = 0;



    // GUI
    const gui = UI.gui;
    // gui.renderOrder = 2;
    gui.open();

    const weather = UI.weather;


    gui.add(weather, 'RainVar', 0, 100).name('Rain').onChange(value => { rainPower = value });
    gui.add(weather, 'SunVar', 0, 100).name('Heat').onChange(value => { sunPower = value });

    var gardencust = gui.addFolder('Garden Customisation');

    gardencust.add(grassOptions, 'grassAmount', 0, 40, 5).name("Grass Total").onChange(function(value){
      GRASS.grassRandomiser(grassOptions.grassAmount,scene);
    });
    gardencust.add(grassOptions, 'time', ['day', 'night']).name("Time").onChange(value => {time = value});

    gardencust.add(grassOptions,'baseSizeX', 0,20,2).name("Garden Length").onChange(function(value){
      updateBase(grassOptions.baseSizeX, grassOptions.baseSizeZ);
    });
    gardencust.add(grassOptions,'baseSizeZ', 0,20,2).name("Garden Width").onChange(function(value){
      updateBase(grassOptions.baseSizeX, grassOptions.baseSizeZ);
    });

    gardencust.open();

    var updateBase = function(sizeX, sizeZ){
      const newBaseGeo = new THREE.PlaneGeometry((sizeX * 10) + 142.86, (sizeZ * 10) + 142.86);
      base.geometry = newBaseGeo;

      const newPathGeo = new THREE.PlaneGeometry((sizeX * 10) + 189.28, (sizeZ * 10) + 189.28);
      path.geometry = newPathGeo;

      const newDirtGeo = new THREE.PlaneGeometry((sizeX * 10) + 250, (sizeZ * 10) + 250);
      dirt.geometry = newDirtGeo;

      const newBuildingGeo = new THREE.BoxGeometry((sizeX * 10) + 250, 400, (sizeZ * 10) + 250);
      building.geometry = newBuildingGeo;

      const newEdgeGeo = new THREE.BoxGeometry((sizeX * 10) + 260, 10, 5);
      const newSideGeo = new THREE.BoxGeometry(5, 10, (sizeZ * 10) + 250);
      frontEdge.geometry = newEdgeGeo;
      backEdge.geometry = newEdgeGeo;
      rightEdge.geometry = newSideGeo;
      leftEdge.geometry = newSideGeo;

      leftEdge.position.set(-(sizeX * 10) /2 + - 127.5, 5, 0);
      rightEdge.position.set((sizeX * 10) /2 + 127.5, 5, 0);
      frontEdge.position.set(0, 5, -(sizeZ * 10) / 2 + - 127.5);
      backEdge.position.set(0, 5, (sizeZ * 10) / 2 + 127.5);
    }

    function animate() {
      const delta = clock.getDelta();
      heat.intensity = sunPower/20;
      rain.visible = rainPower ? true : false;
      posAttr = WEATHER.animateRain(rainPower/-50);
      posAttr.needsUpdate = true;
      PLANTS.weatherEffects(scene, rainPower, sunPower);

      if(rainPower)
        renderer.setClearColor(0x536878);
      else
        renderer.setClearColor(0x87ceeb);

      GRASS.grassRandomiser(grassOptions.grassAmount, scene);
		  ENV.theTime(time, naturalLight, renderer, rainPower);

      if(pointcontrols.isLocked){
        gui.close();
        lock = true;
        if(moveForward){
          pointcontrols.moveForward(3.5);
        } else if (moveRight){
          pointcontrols.moveRight(3.5);
        } else if (moveBackward){
          pointcontrols.moveForward(-3.5);
        } else if (moveLeft){
          pointcontrols.moveRight(-3.5);
        }
      } else {
        gui.open();
        lock = false;
      }

      renderer.render(scene, camera);
      //controls.update();
      requestAnimationFrame(animate);
    }

    init();
    renderer.setClearColor(0x87ceeb);

    var MyResize = function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };

    window.addEventListener('resize', MyResize);

    //moving

    var moveForward = false;
    var moveLeft = false;
    var moveBackward = false;
    var moveRight = false;

    const onKeyDown = function(event){
      switch(event.keyCode){
        case 32: //if space pressed
          pointcontrols.lock();
          camera.position.set(0,40,120);
          break;
        case 87: //w 
          moveForward = true; break;
        case 65: //a
          moveLeft = true; break;
        case 83: //s
          moveBackward = true; break;
        case 68: //d
          moveRight = true; break;
      }
    }

    const onKeyUp = function(event){
      switch(event.keyCode){
        case 87: //w 
          moveForward = false; break;
        case 65: //a
          moveLeft = false; break;
        case 83: //s
          moveBackward = false; break;
        case 68: //d
          moveRight = false; break;
      }
    }

    document.addEventListener( 'keydown', onKeyDown );
    document.addEventListener( 'keyup', onKeyUp );


    // Raycaster
    var raycaster = new THREE.Raycaster();
    document.addEventListener('mousedown', (event) => {
      const mousePos = new THREE.Vector2();
      mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mousePos, camera);

      const intersects = raycaster.intersectObjects(scene.children, true);

      if(lock == false){
        if (intersects.length > 0) {
          if (flowerOptions.deleteMode) {
            // deletion
            for (let intersect of intersects) {
              let target = intersect.object;
              while (target.parent && target.parent !== scene) {
                if (target.parent.name === "Plant") {
                  target = target.parent;
                  break;
                }
                target = target.parent;
              }
              if (target.name === "Plant") {
                scene.remove(target);
                // deleting resources
                target.traverse(node => {
                  if (node.geometry) node.geometry.dispose();
                  if (node.material) node.material.dispose();
                });
                break;
              }
            }
          } else {
            // Handle adding plants
            const floorIntersect = intersects.find(intersect => intersect.object.name === "Dirt");
            if (floorIntersect) {
              const newPosition = floorIntersect.point;
              if (isOutsidePath(newPosition)) {  // Check if the position is outside the path
                switch (flowerOptions.addObject) {
                  case 'Cactus':
                    PLANTS.addCactus(scene, newPosition, flowerOptions.cactusColor);
                    break;
                  case 'Sunflower':
                    PLANTS.addSunflower(scene, newPosition, flowerOptions.sunFlowerColor);
                    break;
                  case 'Zinnias':
                    PLANTS.addZinnias(scene, newPosition, flowerOptions.zinniasColor);
                    break;
                  case 'Lillies':
                    PLANTS.addLillies(scene, newPosition, flowerOptions.lilliesColor);
                    break;
                  case 'Lungwort':
                    PLANTS.addLungwort(scene, newPosition, flowerOptions.lungwortColor);
                    break;
                  case 'Rose':
                    PLANTS.addRose(scene, newPosition);
                    break;
                }
              }
            }
          }
        }
      }
      });
      

    // Check if a position is outside the path
    function isOutsidePath(position) {
      const pathCenter = new THREE.Vector2(0, 0); 
      //const pathSize = new THREE.Vector2(189.28, 189.28); // Size of the path
      const pathSizeX = (grassOptions.baseSizeX * 10) + 189.28;
      const pathSizeZ = (grassOptions.baseSizeZ * 10) + 189.28;

      /*const halfPathSize = pathSize.clone().multiplyScalar(0.5);
      const minX = pathCenter.x - halfPathSize.x;
      const maxX = pathCenter.x + halfPathSize.x;
      const minY = pathCenter.y - halfPathSize.y;
      const maxY = pathCenter.y + halfPathSize.y;*/

      const halfPathSizeX = pathSizeX / 2;
      const halfPathSizeZ = pathSizeZ / 2;
      const minX = pathCenter.x - halfPathSizeX;
      const maxX = pathCenter.x + halfPathSizeX;
      const minY = pathCenter.y - halfPathSizeZ;
      const maxY = pathCenter.y + halfPathSizeZ;

      return (position.x < minX || position.x > maxX || position.z < minY || position.z > maxY);
    }
  
 // TREE MOVINGS

    var trees = [];
    var tree;
    var treeSelected = false;
    var mouse = new THREE.Vector2();
    var selectedTree = null;
    var originalColors = new Map();

    const loaderT = new GLTFLoader().setPath('./Models/jungle_tree/');
    loaderT.load('scene.gltf', (gltf) => {
      tree = gltf.scene;
      scene.add(tree);
      tree.scale.set(5, 5, 5);
      tree.position.x = -1;
      gltf.scene.traverse((node) => 
      {
        if (node.isMesh)
        {
          node.castShadow = true;
        }
      });

      trees.push(tree);
    });

    function onDocumentMouseDown(event) {
      mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
      mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (!treeSelected) {
        var intersects = raycaster.intersectObject(tree, true);

        if (intersects.length > 0) {
          treeSelected = true;
          selectedTree = tree;

          // Store original colors and change to highlight color
          GRASS.storeOriginalColors(selectedTree, originalColors);
          GRASS.changeColor(selectedTree, 0xff0000); 
        }
      } else {
        var intersects2 = raycaster.intersectObject(base, true);

        if (intersects2.length > 0) {
          var pos = intersects2[0].point;
          selectedTree.position.x = pos.x;
          selectedTree.position.z = pos.z;

          // Revert the color back to original
          GRASS.revertColors(selectedTree, originalColors);

          treeSelected = false;
          selectedTree = null;
        }
      }
  }
/*
  //labels

  /*
  const earthDiv = document.createElement( 'div' );
  earthDiv.className = 'label';
  earthDiv.textContent = 'Earth';
  earthDiv.style.backgroundColor = 'transparent'; */

  //the div for the label




  document.addEventListener('mousedown', onDocumentMouseDown);

  </script>
</body>
</html>
