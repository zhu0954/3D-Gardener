<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Gardener</title>
  <style>
    body {
      margin: 0;
      font-family: Monospace;
      background-color: #00c3ff;
      color: #fff;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
    }
    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      text-align: center;
    }

  </style>
</head>
<body>
  <div id="info">
    <p>3D Gardener</p>
  </div>
  <script type="importmap">
    {
      "imports": {
        "three": "./build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import * as WEATHER from './Weather.js';
    import * as PLANTS from './Plants.js';
    import * as UI from './UserInterface.js';
    import * as GRASS from './Grass.js'
    import { OrbitControls } from './jsm/controls/OrbitControls.js';
    import { PointerLockControls } from './jsm/controls/PointerLockControls.js';
    import { GUI } from './build/dat.gui.module.js';
    import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
    import { CSS2DRenderer, CSS2DObject } from './jsm/renderers/CSS2DRenderer.js';

    let scene, camera, renderer, controls, pointcontrols, directionalLight, rain, posAttr, floorMesh, materialFloor, sun, sunOn = false, rainOn = false;
    const options = UI.options;
    const clock = new THREE.Clock();  // Define clock here

    function init() {
      scene = new THREE.Scene();
      var ratio = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(45, ratio, 0.1, 1000);
      sunOn = false;

      camera.position.set(0, 40, 60);
      camera.lookAt(0, 0, 1);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // CONTROLS
      controls = new OrbitControls(camera, renderer.domElement);
      pointcontrols = new PointerLockControls( camera, document.body );

      // Rain
      rain = WEATHER.createRain();
      posAttr = WEATHER.getPositionAttributes();
      scene.add(rain);

      // Sun
      sun = WEATHER.createSun();
      scene.add(sun);
      scene.add(sun.target);

      //Lighting
      var cameralight = new THREE.PointLight(new THREE.Color(1, 1, 1), 0.1); // Reduced intensity
      camera.add(cameralight);
      scene.add(camera);

      var ambientlight = new THREE.AmbientLight(new THREE.Color(1, 1, 1), 0.1); // Reduced intensity
      scene.add(ambientlight);

  
      // Shadows
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.gammaFactor = 2.2;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.75; 

      addRooftopElements();
      // Adding building underneath
      addBuilding();

      animate();
    }
    var lock = false;
    var fogCount = 0;

    function addRooftopElements() {
      const textureLoader = new THREE.TextureLoader();

      // Adding dirt surface
      const colorTexD = textureLoader.load('textures/dirt/Ground048_4K-JPG_Color.jpg');
      const dispTexD = textureLoader.load('textures/dirt/Ground048_4K-JPG_Displacement.jpg');
      const nrmTexD = textureLoader.load('textures/dirt/Ground048_4K-JPG_NormalDX.jpg');
      const occTexD = textureLoader.load('textures/dirt/Ground048_4K-JPG_AmbientOcclusion.jpg');
      const roughTexD = textureLoader.load('textures/dirt/Ground048_4K-JPG_Roughness.jpg');
      const dirtgeoD = new THREE.PlaneGeometry(250, 250);
      const dirtmatD = new THREE.MeshStandardMaterial({
        map: colorTexD,
        normalMap: nrmTexD,
        displacementMap: dispTexD,
        roughnessMap: roughTexD,
        aoMap: occTexD,
        side: THREE.DoubleSide,
      });

      const dirt = new THREE.Mesh(dirtgeoD, dirtmatD);
      dirt.rotation.x = -Math.PI / 2;
      dirt.position.y = 0;
      dirt.name = "Dirt";
      dirt.receiveShadow = true;
      scene.add(dirt);

      // Adding rooftop edges
      const edgeGeo = new THREE.BoxGeometry(250, 10, 5);
      const edgeMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
      
      const frontEdge = new THREE.Mesh(edgeGeo, edgeMat);
      frontEdge.position.set(0, 5, -127.5);
      frontEdge.receiveShadow = true;
      scene.add(frontEdge);

      const backEdge = new THREE.Mesh(edgeGeo, edgeMat);
      backEdge.position.set(0, 5, 127.5);
      backEdge.receiveShadow = true;
      scene.add(backEdge);

      const sideGeo = new THREE.BoxGeometry(5, 10, 250);
      const leftEdge = new THREE.Mesh(sideGeo, edgeMat);
      leftEdge.position.set(-127.5, 5, 0);
      leftEdge.receiveShadow = true;
      scene.add(leftEdge);

      const rightEdge = new THREE.Mesh(sideGeo, edgeMat);
      rightEdge.position.set(127.5, 5, 0);
      rightEdge.receiveShadow = true;
      scene.add(rightEdge);

    }

    function addBuilding() {
      const buildingGeo = new THREE.BoxGeometry(250, 200, 250);
      const buildingMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
      const building = new THREE.Mesh(buildingGeo, buildingMat);
      building.position.set(0, -100, 0);
      building.receiveShadow = true;
      scene.add(building);
    }

    // GUI
    const gui = UI.gui;
   // gui.renderOrder = 2;
   gui.open();

    const weather = UI.weather;


    gui.add(weather, 'RainVar').name('Rain').onChange(value => { rainOn = value });
    gui.add(weather, 'SunVar', 0, 1).name('Heat').onChange(value => { sunOn = value });

    var params = {
		//colour: 0xB6D7A8,
		grassAmount: 10,
		time: 'day'
	};

    var gardencust = gui.addFolder('Garden Customisation');
    //gardencust.addColor(params, 'colour').name("Garden Colour");
    gardencust.add(params, 'grassAmount', 0, 40, 5).name("Grass Total").onChange(function(value){
      GRASS.grassRandomiser(params.grassAmount,scene);
    });
    gardencust.add(params, 'time', ['day', 'night']).name("Time").onChange(function(value){
      if(value == 'day'){
        day = true;
        night = false;
      } else{
        night = true;
        day = false;
      }
    });

    function animate() {
      const delta = clock.getDelta();
      sun.visible = sunOn;
      rain.visible = rainOn;
      posAttr = WEATHER.animateRain();
      posAttr.needsUpdate = true;
      PLANTS.weatherEffects(scene, rainOn, sunOn);
      

      if(rainOn){
        renderer.setClearColor(0x536878);
      } else{
        renderer.setClearColor(0x87ceeb);
      }
        /*
        if(fogCount == 0){
          console.log("adding fog");
          scene.fog = new THREE.Fog( 0xA3DEF6, 100, 200 );
          fogCount++;
        }
        renderer.setClearColor(0x4c4b5c);
      } else {
        if(fogCount == 1){
          console.log("removing fog");

          fogCount--;
          scene.fog = null;
        }*/
        //renderer.setClearColor(0x87ceeb);
      //}

      if(pointcontrols.isLocked){
        gui.close();
        lock = true;
        if(moveForward){
          pointcontrols.moveForward(3.5);
        } else if (moveRight){
          pointcontrols.moveRight(3.5);
        } else if (moveBackward){
          pointcontrols.moveForward(-3.5);
        } else if (moveLeft){
          pointcontrols.moveRight(-3.5);
        }
      } else{
        gui.open();
        lock = false;
      }

      renderer.render(scene, camera);
      //controls.update();
      requestAnimationFrame(animate);
    }

    

    init();
    renderer.setClearColor(0x87ceeb);

    var MyResize = function () {
      var width = window.innerWidth;
      var height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    };

    window.addEventListener('resize', MyResize);

    var count = 0;

  var day = true;
  var night = false;
  const sun2 = new THREE.DirectionalLight(0xFFF49E, 1);
  sun2.position.set(50, 80, -50);
  sun2.castShadow = true;
  sun2.shadow.mapSize.width = 1024; 
  sun2.shadow.mapSize.height = 1024;
  sun2.shadow.camera.near = 0.5; 
  sun2.shadow.camera.far = 750;
  sun2.shadow.camera.left = -200;
  sun2.shadow.camera.right = 200;
  sun2.shadow.camera.top = 250;
  sun2.shadow.camera.bottom = -250;


  const moon = new THREE.PointLight(0x4D7DDD, 0.5);
  moon.position.set(50, 80, 50);

  const ambientLight1 = new THREE.AmbientLight(new THREE.Color(0.5,0.5,0.5), 0.6);
  //scene.add(ambientLight);

  const ambientLight2 = new THREE.AmbientLight(new THREE.Color(0.5,0.5,0.5), 0.3);
  //scene.add(ambientLight);

  var theTime = function(){
    if(day){
      if(count == 1){
        count--;
        scene.remove(moon);
        scene.remove(ambientLight2);
      }
      scene.add(sun2);
      scene.add(ambientLight1);
      count++;
    }
    if(night){
      if(count == 1){
        scene.remove(sun2);
        scene.remove(ambientLight1);
        count--;
      }
      scene.add(ambientLight2);
      scene.add(moon);
      renderer.setClearColor(0x000000); 
      count++;
    }
    
  }

    //moving

    var moveForward = false;
    var moveLeft = false;
    var moveBackward = false;
    var moveRight = false;

  const onKeyDown = function(event){
    switch(event.keyCode){
      case 32: //if space pressed
        pointcontrols.lock();
        camera.position.set(0,40,120);
        break;
      case 87: //w 
        moveForward = true; break;
      case 65: //a
        moveLeft = true; break;
      case 83: //s
        moveBackward = true; break;
      case 68: //d*/
        moveRight = true; break;
    }
  }

  const onKeyUp = function(event){
    switch(event.keyCode){
      case 87: //w 
        moveForward = false; break;
      case 65: //a
        moveLeft = false; break;
      case 83: //s
        moveBackward = false; break;
      case 68: //d*/
        moveRight = false; break;
    }
  }

  document.addEventListener( 'keydown', onKeyDown );
  document.addEventListener( 'keyup', onKeyUp );


    // Raycaster
    var raycaster = new THREE.Raycaster();
    document.addEventListener('mousedown', (event) => {
      const mousePos = new THREE.Vector2();
      mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mousePos, camera);

      const intersects = raycaster.intersectObjects(scene.children, true);

      if(lock == false){
        if (intersects.length > 0) {
          if (options.deleteMode) {
            // deletion
            for (let intersect of intersects) {
              let target = intersect.object;
              while (target.parent && target.parent !== scene) {
                if (target.parent.name === "Plant") {
                  target = target.parent;
                  break;
                }
                target = target.parent;
              }
              if (target.name === "Plant") {
                scene.remove(target);
                // deleting resources
                target.traverse(node => {
                  if (node.geometry) node.geometry.dispose();
                  if (node.material) node.material.dispose();
                });
                break;
              }
            }
          } else {
            // Handle adding plants
            const floorIntersect = intersects.find(intersect => intersect.object.name === "Dirt");
            if (floorIntersect) {
              const newPosition = floorIntersect.point;
              if (isOutsidePath(newPosition)) {  // Check if the position is outside the path
                switch (options.addObject) {
                  case 'Cactus':
                    PLANTS.addCactus(scene, newPosition, options.cactusColor);
                    break;
                  case 'Sunflower':
                    PLANTS.addSunflower(scene, newPosition, options.sunFlowerColor);
                    break;
                  case 'Zinnias':
                    PLANTS.addZinnias(scene, newPosition, options.zinniasColor);
                    break;
                  case 'Lillies':
                    PLANTS.addLillies(scene, newPosition, options.lilliesColor);
                    break;
                  case 'Lungwort':
                    PLANTS.addLungwort(scene, newPosition, options.lungwortColor);
                    break;
                  case 'Rose':
                    PLANTS.addRose(scene, newPosition);
                    break;
                }
              }
            }
          }
        }
      }
      });
      

    // Check if a position is outside the path
    function isOutsidePath(position) {
      const pathCenter = new THREE.Vector2(0, 0); 
      const pathSize = new THREE.Vector2(189.28, 189.28); // Size of the path

      const halfPathSize = pathSize.clone().multiplyScalar(0.5);
      const minX = pathCenter.x - halfPathSize.x;
      const maxX = pathCenter.x + halfPathSize.x;
      const minY = pathCenter.y - halfPathSize.y;
      const maxY = pathCenter.y + halfPathSize.y;

      return (position.x < minX || position.x > maxX || position.z < minY || position.z > maxY);
    }

    // TEXTURES
    const texture = new THREE.TextureLoader();
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    const colorTex = texture.load('textures/bestgrass/Grass004_4K-JPG_Color.jpg');
    const dispTex = texture.load('textures/bestgrass/Grass004_4K-JPG_Displacement.jpg');
    const nrmTex = texture.load('textures/bestgrass/Grass004_4K-JPG_NormalDX.jpg');
    const occTex = texture.load('textures/bestgrass/Grass004_4K-JPG_AmbientOcclusion.jpg');
    const roughTex = texture.load('textures/bestgrass/Grass004_4K-JPG_Roughness.jpg');
    const basegeo = new THREE.PlaneGeometry(142.86, 142.86);
    const basemat = new THREE.MeshStandardMaterial({
      map: colorTex,
      normalMap: nrmTex,
      displacementMap: dispTex,
      roughnessMap: roughTex,
      aoMap: occTex,
      side: THREE.DoubleSide,
    });

    const base = new THREE.Mesh(basegeo, basemat);
    base.rotation.x = -Math.PI / 2;
    base.position.y = 1;
    base.receiveShadow = true;
    scene.add(base);

    const colorTexS = texture.load('textures/path/PavingStones138_4K-JPG_Color.jpg');
    const dispTexS = texture.load('textures/path/PavingStones138_4K-JPG_Displacement.jpg');
    const nrmTexS = texture.load('textures/path/PavingStones138_4K-JPG_NormalDX.jpg');
    const occTexS = texture.load('textures/path/PavingStones138_4K-JPG_AmbientOcclusion.jpg');
    const roughTexS = texture.load('textures/path/PavingStones138_4K-JPG_Roughness.jpg');
    const pathgeoS = new THREE.PlaneGeometry(189.28, 189.28);
    const pathmatS = new THREE.MeshStandardMaterial({
      map: colorTexS,
      normalMap: nrmTexS,
      displacementMap: dispTexS,
      roughnessMap: roughTexS,
      aoMap: occTexS,
      side: THREE.DoubleSide,
    });

    const path = new THREE.Mesh(pathgeoS, pathmatS);
    path.rotation.x = -Math.PI / 2;
    path.position.y = 0.5;
    path.receiveShadow = true;
    scene.add(path);

    const colorTexD = texture.load('textures/dirt/Ground048_4K-JPG_Color.jpg');
    const dispTexD = texture.load('textures/dirt/Ground048_4K-JPG_Displacement.jpg');
    const nrmTexD = texture.load('textures/dirt/Ground048_4K-JPG_NormalDX.jpg');
    const occTexD = texture.load('textures/dirt/Ground048_4K-JPG_AmbientOcclusion.jpg');
    const roughTexD = texture.load('textures/dirt/Ground048_4K-JPG_Roughness.jpg');
    const dirtgeoD = new THREE.PlaneGeometry(250, 250);
    const dirtmatD = new THREE.MeshStandardMaterial({
      map: colorTexD,
      normalMap: nrmTexD,
      displacementMap: dispTexD,
      roughnessMap: roughTexD,
      aoMap: occTexD,
      side: THREE.DoubleSide,
    });

    const dirt = new THREE.Mesh(dirtgeoD, dirtmatD);
    dirt.rotation.x = -Math.PI / 2;
    dirt.position.y = 0;
    dirt.name = "Dirt";
    dirt.receiveShadow = true;
    scene.add(dirt);

    /*
    var handleSun = function(){
    var sungeo = new THREE.SphereGeometry(30,30,30);
    var sunmat = new THREE.MeshBasicMaterial({color:0xffff00});
    var sunnysun = new THREE.Mesh(sungeo,sunmat);
    scene.add(sunnysun);
    sunnysun.position.set(0,120,-200);

    /*var sunnylight = new THREE.AmbientLight(0xffff00, 0.1);
    sunnysun.add(sunnylight);

    var sunnyglo = new THREE.ShaderMaterial(
      {
        uniforms: {},
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
      }
    );
    var glowgeo = new THREE.SphereGeometry(35, 30,30);
    var glow = new THREE.Mesh(glowgeo, sunnyglo);
    /*scene.add(glow);
    glow.position.set(0,120,-200);

    sunnysun.add(glow);
    glow.scale.set(1,1,1);
  
  //handleSun();

  //var animateSun = function(){
    var hangingPos = new THREE.Vector3(0,120,-200);
    var comingIn = new THREE.Vector3(-50,-50,-200);
    var goingAway = new THREE.Vector3(50,-50,-200);
    var duration = 5;
    var time = 0;

    if(sunnysun.position == hangingPos){
      if(time < duration){
        time += Time.deltaTime;
        sunnysun.position.x += 50;
        sunnysun.position.y -= -50;
      }
    }
  }
  */

    var MyUpdateLoop = function (){
      //basegeo.color = new THREE.Color(params.colour);
      GRASS.grassRandomiser(params.grassAmount, scene);
		  theTime();
      renderer.render(scene,camera);
      requestAnimationFrame(MyUpdateLoop);
    };
    MyUpdateLoop();

 // TREE MOVINGS

    var trees = [];
    var tree;
    var treeSelected = false;
    var mouse = new THREE.Vector2();
    var selectedTree = null;
    var originalColors = new Map();

    const loaderT = new GLTFLoader().setPath('./Models/jungle_tree/');
    loaderT.load('scene.gltf', (gltf) => {
      tree = gltf.scene;
      scene.add(tree);
      tree.scale.set(5, 5, 5);
      tree.position.x = -1;
      gltf.scene.traverse((node) => 
      {
        if (node.isMesh)
        {
          node.castShadow = true;
        }
      });

      trees.push(tree);
    });

    function storeOriginalColors(object) {
      object.traverse((child) => {
        if (child.isMesh) {
          originalColors.set(child.uuid, child.material.color.clone());
        }
      });
    }

    function changeColor(object, color) {
      object.traverse((child) => {
        if (child.isMesh) {
          child.material.color.set(color);
        }
      });
    }
    function revertColors(object) {
      object.traverse((child) => {
        if (child.isMesh && originalColors.has(child.uuid)) {
          child.material.color.copy(originalColors.get(child.uuid));
        }
      });
    }
    function onDocumentMouseDown(event) {
      mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
      mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (!treeSelected) {
        var intersects = raycaster.intersectObject(tree, true);

        if (intersects.length > 0) {
          console.log("CLICKED TREE");
          treeSelected = true;
          selectedTree = tree;

          // Store original colors and change to highlight color
          storeOriginalColors(selectedTree);
          changeColor(selectedTree, 0xff0000); 
        }
      } else {
        var intersects2 = raycaster.intersectObject(base, true);

        if (intersects2.length > 0) {
          console.log("CLICKED BASE");

          var pos = intersects2[0].point;
          console.log("Placed!");
          selectedTree.position.x = pos.x;
          selectedTree.position.z = pos.z;

          // Revert the color back to original
          revertColors(selectedTree);

          treeSelected = false;
          selectedTree = null;
        }
      }
  }
/*
  //labels

  /*
  const earthDiv = document.createElement( 'div' );
  earthDiv.className = 'label';
  earthDiv.textContent = 'Earth';
  earthDiv.style.backgroundColor = 'transparent'; */

  //the div for the label




  document.addEventListener('mousedown', onDocumentMouseDown, false);

    document.addEventListener('mousedown', onDocumentMouseDown, false);

  </script>
</body>
</html>
